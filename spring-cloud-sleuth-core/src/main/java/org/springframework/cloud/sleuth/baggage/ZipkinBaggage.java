/** Generated by BaggageBuffersCompiler */
package org.springframework.cloud.sleuth.baggage;

import edu.brown.cs.systems.tracingplane.baggage_buffers.BaggageBuffers;
import edu.brown.cs.systems.tracingplane.baggage_buffers.Registrations;
import edu.brown.cs.systems.tracingplane.baggage_buffers.api.Bag;
import edu.brown.cs.systems.tracingplane.baggage_buffers.api.BaggageHandler;
import edu.brown.cs.systems.tracingplane.baggage_buffers.api.Brancher;
import edu.brown.cs.systems.tracingplane.baggage_buffers.api.Joiner;
import edu.brown.cs.systems.tracingplane.baggage_buffers.api.Parser;
import edu.brown.cs.systems.tracingplane.baggage_buffers.api.Serializer;
import edu.brown.cs.systems.tracingplane.baggage_buffers.impl.BBUtils;
import edu.brown.cs.systems.tracingplane.baggage_buffers.impl.Branchers;
import edu.brown.cs.systems.tracingplane.baggage_buffers.impl.Joiners;
import edu.brown.cs.systems.tracingplane.baggage_buffers.impl.Parsers;
import edu.brown.cs.systems.tracingplane.baggage_buffers.impl.Serializers;
import edu.brown.cs.systems.tracingplane.baggage_layer.BagKey;
import edu.brown.cs.systems.tracingplane.baggage_layer.protocol.BaggageReader;
import edu.brown.cs.systems.tracingplane.baggage_layer.protocol.BaggageWriter;
import edu.brown.cs.systems.tracingplane.transit_layer.Baggage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class ZipkinBaggage implements Bag {

    private static final Logger _log = LoggerFactory.getLogger(ZipkinBaggage.class);

    public Long traceID = null;
    public Long spanID = null;
    public Long parentSpanID = null;
    public Boolean sampled = false;

    public boolean _overflow = false;

    /**
    * <p>
    * Get the {@link ZipkinBaggage} set in the {@link Baggage} carried by the current thread. If no baggage is being
    * carried by the current thread, or if there is no ZipkinBaggage in it, then this method returns {@code null}.
    * </p>
    *
    * <p>
    * To get ZipkinBaggage from a specific Baggage instance, use {@link #getFrom(Baggage)}.
    * </p>
    *
    * @return the ZipkinBaggage being carried in the {@link Baggage} of the current thread, or {@code null}
    *         if none is being carried. The returned instance maybe be modified and modifications will be reflected in
    *         the baggage.
    */
    public static ZipkinBaggage get() {
        Bag bag = BaggageBuffers.get(Handler.registration());
        if (bag instanceof ZipkinBaggage) {
            return (ZipkinBaggage) bag;
        } else {
            return null;
        }
    }

    /**
    * <p>
    * Get the {@link ZipkinBaggage} set in {@code baggage}. If {@code baggage} has no ZipkinBaggage set then
    * this method returns null.
    * </p>
    *
    * <p>
    * This method does <b>not</b> affect the Baggage being carried by the current thread.  To get ZipkinBaggage
    * from the current thread's Baggage, use {@link #get()}.
    * </p>
    *
    * @param baggage A baggage instance to get the {@link ZipkinBaggage} from
    * @return the {@link ZipkinBaggage} instance being carried in {@code baggage}, or {@code null} if none is being carried.
    *         The returned instance can be modified, and modifications will be reflected in the baggage.
    */
    public static ZipkinBaggage getFrom(Baggage baggage) {
        Bag bag = BaggageBuffers.get(baggage, Handler.registration());
        if (bag instanceof ZipkinBaggage) {
            return (ZipkinBaggage) bag;
        } else if (bag != null) {
            Handler.checkRegistration();
        }
        return null;
    }

    /**
    * <p>
    * Update the {@link ZipkinBaggage} set in the current thread's baggage. This method will overwrite any existing
    * ZipkinBaggage set in the current thread's baggage.
    * </p>
    *
    * <p>
    * To set the {@link ZipkinBaggage} in a specific {@link Baggage} instance, use
    * {@link #setIn(Baggage, ZipkinBaggage)}
    * </p>
    *
    * @param zipkinBaggage the new {@link ZipkinBaggage} to set in the current thread's {@link Baggage}. If {@code null}
    *            then any existing mappings will be removed.
    */
    public static void set(ZipkinBaggage zipkinBaggage) {
        BaggageBuffers.set(Handler.registration(), zipkinBaggage);
    }

    /**
    * <p>
    * Update the {@link ZipkinBaggage} set in {@code baggage}. This method will overwrite any existing
    * ZipkinBaggage set in {@code baggage}.
    * </p>
    *
    * <p>
    * This method does <b>not</b> affect the {@link Baggage} being carried by the current thread. To set the
    * {@link ZipkinBaggage} for the current thread, use {@link #set(ZipkinBaggage)}
    * </p>
    *
    * @param baggage A baggage instance to set the {@link ZipkinBaggage} in
    * @param zipkinBaggage the new ZipkinBaggage to set in {@code baggage}. If {@code null}, it will remove any
    *            mapping present.
    * @return a possibly new {@link Baggage} instance that contains all previous mappings plus the new mapping.
    */
    public static Baggage setIn(Baggage baggage, ZipkinBaggage zipkinBaggage) {
        return BaggageBuffers.set(baggage, Handler.registration(), zipkinBaggage);
    }

    @Override
    public BaggageHandler<?> handler() {
        return Handler.instance;
    }

    @Override
    public String toString() {
        StringBuilder b = new StringBuilder();
        b.append("ZipkinBaggage{\n");
            b.append(this.traceID == null ? "" : BBUtils.indent(String.format("traceID = %s\n", String.valueOf(this.traceID))));
            b.append(this.spanID == null ? "" : BBUtils.indent(String.format("spanID = %s\n", String.valueOf(this.spanID))));
            b.append(this.parentSpanID == null ? "" : BBUtils.indent(String.format("parentSpanID = %s\n", String.valueOf(this.parentSpanID))));
            b.append(this.sampled == null ? "" : BBUtils.indent(String.format("sampled = %s\n", String.valueOf(this.sampled))));
            b.append("}");
        return b.toString();
    }

    public static class Handler implements BaggageHandler<ZipkinBaggage> {

        public static final Handler instance = new Handler();
        private static BagKey registration = null;

        static synchronized BagKey checkRegistration() {
            registration = Registrations.lookup(instance);
            if (registration == null) {
                _log.error("ZipkinBaggage MUST be registered to a key before it can be propagated.  " +
                "There is currently no registration for ZipkinBaggage and it will not be propagated. " +
                "To register a bag set the baggage-buffers.bags property in your application.conf " +
                "or with -Dbaggage-buffers.bags flag (eg, for key 10, -Dbaggage-buffers.bags.10=" + ZipkinBaggage.class.getName());
            }
            return registration;
        }

        static BagKey registration() {
            return registration == null ? checkRegistration() : registration;
        }

        private Handler(){}

        private static final BagKey _traceIDKey = BagKey.indexed(0);
        private static final BagKey _spanIDKey = BagKey.indexed(1);
        private static final BagKey _parentSpanIDKey = BagKey.indexed(2);
        private static final BagKey _sampledKey = BagKey.indexed(3);

        private static final Parser<Long> _traceIDParser = Parsers.sfixed64Parser();
        private static final Serializer<Long> _traceIDSerializer = Serializers.sfixed64Serializer();
        private static final Brancher<Long> _traceIDBrancher = Branchers.<Long>noop();
        private static final Joiner<Long> _traceIDJoiner = Joiners.<Long>first();

        private static final Parser<Long> _spanIDParser = Parsers.sfixed64Parser();
        private static final Serializer<Long> _spanIDSerializer = Serializers.sfixed64Serializer();
        private static final Brancher<Long> _spanIDBrancher = Branchers.<Long>noop();
        private static final Joiner<Long> _spanIDJoiner = Joiners.<Long>first();

        private static final Parser<Long> _parentSpanIDParser = Parsers.sfixed64Parser();
        private static final Serializer<Long> _parentSpanIDSerializer = Serializers.sfixed64Serializer();
        private static final Brancher<Long> _parentSpanIDBrancher = Branchers.<Long>noop();
        private static final Joiner<Long> _parentSpanIDJoiner = Joiners.<Long>first();

        private static final Parser<Boolean> _sampledParser = Parsers.taintParser();
        private static final Serializer<Boolean> _sampledSerializer = Serializers.taintSerializer();
        private static final Brancher<Boolean> _sampledBrancher = Branchers.<Boolean>noop();
        private static final Joiner<Boolean> _sampledJoiner = Joiners.or();

        @Override
        public boolean isInstance(Bag bag) {
            return bag == null || bag instanceof ZipkinBaggage;
        }

        @Override
        public ZipkinBaggage parse(BaggageReader reader) {
            ZipkinBaggage instance = new ZipkinBaggage();

            if (reader.enter(_traceIDKey)) {
                instance.traceID = _traceIDParser.parse(reader);
                reader.exit();
            }

            if (reader.enter(_spanIDKey)) {
                instance.spanID = _spanIDParser.parse(reader);
                reader.exit();
            }

            if (reader.enter(_parentSpanIDKey)) {
                instance.parentSpanID = _parentSpanIDParser.parse(reader);
                reader.exit();
            }

            if (reader.enter(_sampledKey)) {
                instance.sampled = _sampledParser.parse(reader);
                reader.exit();
            }
            instance._overflow = reader.didOverflow();

            return instance;
        }

        @Override
        public void serialize(BaggageWriter writer, ZipkinBaggage instance) {
            if (instance == null) {
                return;
            }

            writer.didOverflowHere(instance._overflow);

            if (instance.traceID != null) {
                writer.enter(_traceIDKey);
                _traceIDSerializer.serialize(writer, instance.traceID);
                writer.exit();
            }

            if (instance.spanID != null) {
                writer.enter(_spanIDKey);
                _spanIDSerializer.serialize(writer, instance.spanID);
                writer.exit();
            }

            if (instance.parentSpanID != null) {
                writer.enter(_parentSpanIDKey);
                _parentSpanIDSerializer.serialize(writer, instance.parentSpanID);
                writer.exit();
            }

            if (instance.sampled != null) {
                writer.enter(_sampledKey);
                _sampledSerializer.serialize(writer, instance.sampled);
                writer.exit();
            }
        }

        @Override
        public ZipkinBaggage branch(ZipkinBaggage instance) {
            if (instance == null) {
                return null;
            }

            ZipkinBaggage newInstance = new ZipkinBaggage();
            newInstance.traceID = _traceIDBrancher.branch(instance.traceID);
            newInstance.spanID = _spanIDBrancher.branch(instance.spanID);
            newInstance.parentSpanID = _parentSpanIDBrancher.branch(instance.parentSpanID);
            newInstance.sampled = _sampledBrancher.branch(instance.sampled);
            return newInstance;
        }

        @Override
        public ZipkinBaggage join(ZipkinBaggage left, ZipkinBaggage right) {
            if (left == null) {
                return right;
            } else if (right == null) {
                return left;
            } else {
                left.traceID = _traceIDJoiner.join(left.traceID, right.traceID);
                left.spanID = _spanIDJoiner.join(left.spanID, right.spanID);
                left.parentSpanID = _parentSpanIDJoiner.join(left.parentSpanID, right.parentSpanID);
                left.sampled = _sampledJoiner.join(left.sampled, right.sampled);
                return left;
            }
        }
    }
}